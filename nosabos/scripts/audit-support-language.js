#!/usr/bin/env node
/* global process */

import fs from "fs";
import path from "path";

const ROOT = process.cwd();
const SRC_DIR = path.join(ROOT, "src");
const OUTPUT_MD = path.join(ROOT, "docs", "support-language-expansion.md");
const OUTPUT_JSON = path.join(ROOT, "docs", "support-language-audit.json");

const IGNORE_SEGMENTS = [
  `${path.sep}assets${path.sep}`,
  `${path.sep}data${path.sep}`,
  `${path.sep}translations${path.sep}`,
  `${path.sep}flagsIcons${path.sep}flags.jsx`,
  `${path.sep}utils${path.sep}translation.jsx`,
];

const EXTENSIONS = new Set([".js", ".jsx", ".ts", ".tsx"]);

const LANGUAGE_BRANCH_PATTERNS = [
  /\bappLanguage\s*===\s*["'](es|en)["']/,
  /\bsupportLang\s*===\s*["'](es|en)["']/,
  /\buiLang\s*===\s*["'](es|en)["']/,
  /\buserLanguage\s*===\s*["'](es|en)["']/,
  /\blang\s*===\s*["'](es|en)["']/,
  /\[\s*["']en["']\s*,\s*["']es["']\s*\]/,
  /localStorage\.getItem\(["']appLanguage["']\)\s*===\s*["']es["']/,
  /\?\s*["']es["']\s*:\s*["']en["']/,
];

const UI_LITERAL_PATTERNS = [
  /\b(title|description|label|placeholder|loadingText|header|text)\s*:\s*["'`](?![a-z0-9_]+\b)([^"'`]*[A-Za-z][^"'`]*)["'`]/,
  /\b(aria-label|placeholder|loadingText|title|label)=\{?["'`]([^"'`]*[A-Za-z][^"'`]*)["'`]\}?/,
  /\?\s*["'`][^"'`]*[A-Za-z][^"'`]*["'`]\s*:\s*["'`][^"'`]*[A-Za-z][^"'`]*["'`]/,
  /\|\|\s*["'`][^"'`]*[A-Za-z][^"'`]*["'`]/,
  /\?\?\s*["'`][^"'`]*[A-Za-z][^"'`]*["'`]/,
];

const NON_UI_HINTS = [
  "http://",
  "https://",
  "import ",
  "export ",
  "console.",
  "throw new Error",
  "eslint",
  "TODO",
  "FIXME",
  "model",
  "npub",
  "nsec",
  "regex",
  "rgba",
  "linear-gradient",
  "@keyframes",
  "fontFamily",
  "boxShadow",
  "borderColor",
  "schema",
  "JSON",
  "type:",
  "role:",
  "phase:",
  "prompt",
  "instruction",
  "generateContent",
  "useMemo",
];

function walk(dir, acc = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      walk(full, acc);
      continue;
    }
    const ext = path.extname(entry.name);
    if (!EXTENSIONS.has(ext)) continue;
    if (IGNORE_SEGMENTS.some((seg) => full.includes(seg))) continue;
    acc.push(full);
  }
  return acc;
}

function shouldSkipLine(line) {
  const trimmed = line.trim();
  if (!trimmed) return true;
  if (trimmed.startsWith("//") || trimmed.startsWith("/*") || trimmed.startsWith("*")) return true;
  if (trimmed.startsWith("import ") || trimmed.startsWith("export ")) return true;
  return false;
}

function hasUiLiteralCandidate(line) {
  if (!line.includes('"') && !line.includes("'") && !line.includes("`")) {
    return false;
  }
  if (NON_UI_HINTS.some((hint) => line.includes(hint))) return false;
  if (/\bt\(\s*["'][^"']+["']\s*\)/.test(line)) return false;
  if (/translations\[/.test(line)) return false;
  if (/\b(language_|onboarding_|tabs_|ra_|app_|teams_|flashcard_|skill_tree_)/.test(line) && /\b:\s*["']/.test(line)) return false;
  return UI_LITERAL_PATTERNS.some((re) => re.test(line));
}

function auditFile(filePath) {
  const relPath = path.relative(ROOT, filePath);
  const content = fs.readFileSync(filePath, "utf8");
  const lines = content.split(/\r?\n/);
  const matches = [];

  lines.forEach((line, idx) => {
    const lineNo = idx + 1;
    if (shouldSkipLine(line)) return;

    const branchHit = LANGUAGE_BRANCH_PATTERNS.some((re) => re.test(line));
    if (branchHit) {
      matches.push({
        type: "language_branch",
        line: lineNo,
        snippet: line.trim().slice(0, 220),
      });
      return;
    }

    if (hasUiLiteralCandidate(line)) {
      matches.push({
        type: "ui_literal_candidate",
        line: lineNo,
        snippet: line.trim().slice(0, 220),
      });
    }
  });

  return {
    file: relPath,
    total: matches.length,
    languageBranches: matches.filter((m) => m.type === "language_branch").length,
    uiLiteralCandidates: matches.filter((m) => m.type === "ui_literal_candidate").length,
    matches,
  };
}

function toMd(auditRows, totals) {
  const lines = [];
  lines.push("# Support Language Expansion Document");
  lines.push("");
  lines.push("## Scope");
  lines.push("- Goal: consolidate front-facing text and language branching into translation keys and language config so support/app languages can scale beyond English/Spanish.");
  lines.push("- Source audit generated by `scripts/audit-support-language.js`.");
  lines.push("- Includes `src/App.jsx`, `src/components/*`, `src/hooks/*`, `src/utils/*` (excluding static data/assets/translation dictionaries).");
  lines.push("");
  lines.push("## Totals");
  lines.push(`- Files scanned: ${totals.filesScanned}`);
  lines.push(`- Files with findings: ${totals.filesWithFindings}`);
  lines.push(`- Total findings: ${totals.totalFindings}`);
  lines.push(`- ` + "`language_branch`" + ` findings: ${totals.languageBranches}`);
  lines.push(`- ` + "`ui_literal_candidate`" + ` findings: ${totals.uiLiteralCandidates}`);
  lines.push("");
  lines.push("## File-By-File Backlog");
  lines.push("| File | Total | Language Branches | UI Literal Candidates |");
  lines.push("|---|---:|---:|---:|");
  for (const row of auditRows) {
    if (row.total === 0) continue;
    lines.push(`| ${row.file} | ${row.total} | ${row.languageBranches} | ${row.uiLiteralCandidates} |`);
  }
  lines.push("");
  lines.push("## Detailed Findings");
  for (const row of auditRows) {
    if (row.total === 0) continue;
    lines.push(`### ${row.file}`);
    for (const m of row.matches) {
      lines.push(`- ${m.type} @ L${m.line}: \`${m.snippet.replace(/`/g, "'")}\``);
    }
    lines.push("");
  }

  lines.push("## Consolidation Rules");
  lines.push("1. Replace `appLanguage/supportLang/uiLang/userLanguage` direct `en/es` branches with translation keys or language config helpers.");
  lines.push("2. Move all user-facing literal strings to `src/utils/translation.jsx` keys first (en/es), then add language packs for all support languages.");
  lines.push("3. Keep one source of truth for supported languages in `src/constants/languages.js` and consume it from onboarding/settings/chat/prompts.");
  lines.push("4. Add lint/CI check to fail on new `language_branch` patterns outside translation/config files.");
  lines.push("");
  lines.push("## Rollout Order");
  lines.push("1. High volume files: `src/components/Vocabulary.jsx`, `src/components/Stories.jsx`, `src/App.jsx`, `src/components/GrammarBook.jsx`, `src/components/JobScript.jsx`, `src/components/AlphabetBootcamp.jsx`.");
  lines.push("2. Medium files: `src/components/IdentityDrawer.jsx`, `src/components/LessonGroupQuiz.jsx`, `src/components/RealTimeTest.jsx`, `src/components/Randomize.jsx`, `src/components/Conversations.jsx`, `src/components/History.jsx`.");
  lines.push("3. Remaining files and helper hooks.");

  return lines.join("\n");
}

function main() {
  const files = walk(SRC_DIR);
  const rows = files.map(auditFile);
  rows.sort((a, b) => b.total - a.total || a.file.localeCompare(b.file));

  const totals = {
    filesScanned: rows.length,
    filesWithFindings: rows.filter((r) => r.total > 0).length,
    totalFindings: rows.reduce((sum, r) => sum + r.total, 0),
    languageBranches: rows.reduce((sum, r) => sum + r.languageBranches, 0),
    uiLiteralCandidates: rows.reduce((sum, r) => sum + r.uiLiteralCandidates, 0),
  };

  fs.mkdirSync(path.dirname(OUTPUT_MD), { recursive: true });
  fs.writeFileSync(
    OUTPUT_JSON,
    JSON.stringify({ generatedAt: new Date().toISOString(), totals, rows }, null, 2),
    "utf8",
  );
  fs.writeFileSync(OUTPUT_MD, toMd(rows, totals), "utf8");

  const top = rows.filter((r) => r.total > 0).slice(0, 12);
  console.log(JSON.stringify({ totals, top }, null, 2));
}

main();
